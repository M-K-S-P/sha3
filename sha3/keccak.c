#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>

const uint64_t RC[24]={ 0x0000000000000001,
		       0x0000000000008082, 0x800000000000808A,
		       0x8000000080008000, 0x000000000000808B,
		       0x0000000080000001, 0x8000000080008081,
		       0x8000000000008009, 0x000000000000008A,
		       0x0000000000000088, 0x0000000080008009,
		       0x000000008000000A, 0x000000008000808B,
		       0x800000000000008B, 0x8000000000008089,
		       0x8000000000008003, 0x8000000000008002,
		       0x8000000000000080, 0x000000000000800A,
		       0x800000008000000A, 0x8000000080008081,
		       0x8000000000008080, 0x0000000080000001,
		       0x8000000080008008 };

const uint64_t r[5][5]={ 
      {0,36,3,41,18},
			{1,44,10,45,2},
			{62,6,43,15,61},
			{28,55,25,21,56},
			{27,20,39,8,14}
};

uint64_t** sha3_round(uint64_t **S, int rc) { 

  uint64_t Q[5];
  uint64_t D[5];
  
  for(int i = 0; i < 5; i ++){
    Q[i] = S[i][0] ^ S[i][1] ^ S[i][2] ^ S[i][3] ^ S[i][4];
  }
  for(int i = 0; i < 5; i ++){
    D[i] = Q[(i + 4) % 5] ^ ((Q[(i + 1) % 5] << 1) | (Q[(i + 1) % 5] >> 63));
  }
  for(int x = 0; x < 5; x++){
    for(int y = 0; y < 5; y++){
      S[x][y] ^= D[x]; 
    }
  }
  uint64_t C[5][5];
  for(int x = 0; x < 5; x++){
    for(int y = 0; y < 5; y++){
      C[y][(2*x+3*y) % 5]=((S[x][y] << r[x][y]) | (S[x][y] >> (64-r[x][y])));
    }
  }
  for(int x = 0; x < 5; x++){
    for(int y = 0; y < 5; y++){
      S[x][y] = C[x][y] ^ ((~C[(x+1) % 5][y]) & C[(x+2) % 5][y]);
    }
  }
  S[0][0] = S[0][0] ^ rc;

  return S;
  
}


uint64_t **keccak_f(uint64_t **A){
  for(int32_t i=0; i<24; i++){
    A = sha3_round(A, RC[i]);
  }
  return A;
}

